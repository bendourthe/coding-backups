clear all; close all;

% Function: Uses the txt-files with transformations and coordinate systems 
% generated by "CTmotion_plusplus_relToStatic", a plot with helical axes
% and average helical axes.
% 
% Dependencies: 
%   txt2mat.m
%   IntersectLineAndPlane.m 
%       DistanceFromVertexToPlane.m 
%           TRI_Normals.m	
%   VectorNorms.m
%   screw.m
%   FindPivotPoint
%   DistanceFromVertexToLine
%       VectorNorms.m
% 
% Created by: Frederik Van Eeghem, 2012
% FK, 17/4/2013: added dependencies

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Controle panel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Determine which files (phases/frames) are available
available = [1,2,3,4,5,6,8,9,10,12,13,15,16,17,19,20];

% Directery of txt-files with transformations and interial axes 
dir = 'C:\mimics\Medical Imaging\4D CT opposition Faes\4D CT 24-6-2013\STL\';
    filename{1} = 'RotTransData_tovStat1.txt';
    filename{2} = 'RotTransData_tovStat2.txt';
    filename{3} = 'RotTransData_tovStat3.txt';
    filename{4} = 'RotTransData_tovStat4.txt';
    filename{5} = 'RotTransData_tovStat5.txt';
    filename{6} = 'RotTransData_tovStat6.txt';
    filename{7} = 'RotTransData_tovStat7.txt';
    filename{8} = 'RotTransData_tovStat8.txt';
    filename{9} = 'RotTransData_tovStat9.txt';
    filename{10} = 'RotTransData_tovStat10.txt';
    filename{11} = 'RotTransData_tovStat11.txt';
    filename{12} = 'RotTransData_tovStat12.txt';
    filename{13} = 'RotTransData_tovStat13.txt';
    filename{14} = 'RotTransData_tovStat14.txt';
    filename{15} = 'RotTransData_tovStat15.txt';
    filename{16} = 'RotTransData_tovStat16.txt';
    filename{17} = 'RotTransData_tovStat17.txt';
    filename{18} = 'RotTransData_tovStat18.txt';
    filename{19} = 'RotTransData_tovStat19.txt';
    filename{20} = 'RotTransData_tovStat20.txt';
filenameInertialAX = 'InertialAx1.txt';
fileInertialAX = [dir filenameInertialAX];
filenameAX = 'RadAxes_tovStat1.txt';
fileAX = [dir filenameAX];
fig = 1; %1 to plot figure, else 0

% STL's filenames from each bone (static scan) 
Rad_static = '611L_static_rad.stl';
MC_static = '611L_static_mc1.stl';
Sca_static = '611L_static_sca.stl';
Trap_static = '611L_static_trp.stl';

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------%
% Loading data %
%--------------%

% preallocating variables 

R_Rad = cell(size(available));
T_Rad = cell(size(available));
H_Rad = cell(size(available));
R_MC = cell(size(available));
T_MC = cell(size(available));
R_Trap = cell(size(available));
T_Trap = cell(size(available));
R_Sca = cell(size(available));
T_Sca = cell(size(available));

ERROR_Rad = cell(size(available));
ERROR_MC = cell(size(available));
ERROR_Trap = cell(size(available));
ERROR_Sca = cell(size(available));

% Loading data
for nr = available
    A = txt2mat([dir filename{nr}]);
    
    R_Rad{nr} = A(1:3,1:3);
    T_Rad{nr} = A(1:3,4);
    H_Rad{nr} = [R_Rad{nr}, T_Rad{nr}; 0 0 0 1];
    R_MC{nr} = A(4:6,1:3);
    T_MC{nr} = A(4:6,4);
    R_Trap{nr} = A(7:9,1:3);
    T_Trap{nr} = A(7:9,4);
    R_Sca{nr} = A(10:12,1:3);
    T_Sca{nr} = A(10:12,4);
    
    ERROR_Rad{nr} = A(13,1);
    ERROR_MC{nr} = A(14,1);
    ERROR_Trap{nr} = A(15,1);
    ERROR_Sca{nr} = A(16,1);
    
end

%---------------%
% Transforming %
%---------------%
% All transformations are in the coordinate system of the underlying 
% bone fragment of the static scan. Grouping transformations eg; frame 1 ->
% static, static -> frame 2 to get the transition from frame 1 to frame 2.

% Alle transformaties in assenstelsel van onderliggend botfragement van
% statische scan. Steeds transformaties samenstellen: 
% vb frame 1 -> statisch en dan statisch -> frame2 om zo de overgang 
% frame 1 -> frame2 te bekomen

% preallocating for speed
H_MC = cell(1,length(available)-1);
H_Trap = cell(1,length(available)-1);
H_Sca = cell(1,length(available)-1);

for nr = 1:length(available)-1
    H_MC{nr} = [R_MC{available(nr+1)}.', -R_MC{available(nr+1)}.'*T_MC{available(nr+1)}; 0 0 0 1] * [R_MC{available(nr)}, T_MC{available(nr)}; 0 0 0 1];
    H_Trap{nr} = [R_Trap{available(nr+1)}.', -R_Trap{available(nr+1)}.'*T_Trap{available(nr+1)}; 0 0 0 1] * [R_Trap{available(nr)}, T_Trap{available(nr)}; 0 0 0 1];
    H_Sca{nr} = [R_Sca{available(nr+1)}.', -R_Sca{available(nr+1)}.'*T_Sca{available(nr+1)}; 0 0 0 1] * [R_Sca{available(nr)}, T_Sca{available(nr)}; 0 0 0 1];
end

% Linking to radius
Ax = txt2mat(fileInertialAX);
Trap2Rad = [Ax(1:3,1:3) Ax(1:3,4); 0 0 0 1];
Sca2Rad = [Ax(4:6,1:3) Ax(4:6,4); 0 0 0 1];
    
%------------------------%
% Calculating helical axes %
%------------------------%

% preallocating for speed
n_MC = zeros(3,length(available)-1);
point_MC = zeros(3,length(available)-1);
phi_MC = zeros(1,length(available)-1);
t_MC = zeros(1,length(available)-1);
n_Trap = zeros(3,length(available)-1);
point_Trap = zeros(3,length(available)-1);
phi_Trap = zeros(1,length(available)-1);
t_Trap = zeros(1,length(available)-1);
n_Sca = zeros(3,length(available)-1);
point_Sca = zeros(3,length(available)-1);
phi_Sca = zeros(1,length(available)-1);
t_Sca = zeros(1,length(available)-1);

% Helical axis between frames
for nr = 1:length(available)-1
    [n_MC(:,nr),point_MC(:,nr),phi_MC(:,nr),t_MC(:,nr)] = screw(H_MC{nr},1);
    n_MC_tmp = (Trap2Rad * [n_MC(:,nr) ; 1]); n_MC(:,nr) = n_MC_tmp(1:3)/norm(n_MC_tmp(1:3));
    point_MC_tmp = (Trap2Rad * [point_MC(:,nr) ; 1]); point_MC(:,nr) = point_MC_tmp(1:3);
    [n_Trap(:,nr),point_Trap(:,nr),phi_Trap(:,nr),t_Trap(:,nr)] = screw(H_Trap{nr});
    n_Trap_tmp = (Sca2Rad * [n_Trap(:,nr) ; 1]); n_Trap(:,nr) = n_Trap_tmp(1:3)/norm(n_Trap_tmp(1:3));
    point_Trap_tmp = (Sca2Rad * [point_Trap(:,nr) ; 1]); point_Trap(:,nr) = point_Trap_tmp(1:3);
    [n_Sca(:,nr),point_Sca(:,nr),phi_Sca(:,nr),t_Sca(:,nr)] = screw(H_Sca{nr});
end

% Average helixal axis based on 2 points

lines = zeros((2*(length(available)-1))*3,3);
lines(1:2:end-1,:) = [point_Sca'; point_Trap'; point_MC'];
lines(2:2:end,:) = [(point_Sca+n_Sca)'; (point_Trap+n_Trap)'; (point_MC+n_MC)'];
planes = [-20 0 0; -20 1 0; -20 0 1; 30 0 0; 30 1 0; 30 0 1];
vertices = IntersectLineAndPlane(lines, planes);
average = [mean(vertices(1:(length(available)-1),:,1),1);
            mean(vertices(1:(length(available)-1),:,2),1);
            mean(vertices(length(available):2*(length(available)-1),:,1),1);
            mean(vertices(length(available):2*(length(available)-1),:,2),1);
            mean(vertices((2*(length(available)-1)+1):3*(length(available)-1),:,1),1);
            mean(vertices((2*(length(available)-1)+1):3*(length(available)-1),:,2),1)];
        
% Calculationg PivotPoint (could take a while)
[PivotPoint_Sca, ssd_Sca] = FindPivotPoint(point_Sca',n_Sca',[0 0 0]);
[PivotPoint_Trap, ssd_Trap] = FindPivotPoint(point_Trap',n_Trap',[0 0 0]);
[PivotPoint_MC, ssd_MC] = FindPivotPoint(point_MC',n_MC',[0 0 0]);
PivotPoints = [PivotPoint_Sca; PivotPoint_Trap; PivotPoint_MC];


%---------%
% Plotting %
%---------%

if(fig)
    % if fig = 1
    % loading data (stl's and radius CS)
    [F_Rad, V_Rad] =  STL_ReadFile([dir Rad_static],true);
    [F_MC, V_MC] =  STL_ReadFile([dir MC_static],true);
    [F_Trap, V_Trap] =  STL_ReadFile([dir Trap_static],true);
    [F_Sca, V_Sca] =  STL_ReadFile([dir Sca_static],true);
    A = txt2mat(fileAX);
    O = A(1,:);
    Y = A(2,:);
    Z = A(3,:);
    Origin = O;
    Yaxis = (Y-O)/norm(Y-O);
    Zaxis = (Z-O)/norm(Z-O);
    Xaxis = cross(Yaxis,Zaxis)/norm(cross(Yaxis,Zaxis));
    Zaxis = cross(Xaxis,Yaxis)/norm(cross(Xaxis,Yaxis));
    % Converging to radius CS
    RotMat = [Xaxis', Yaxis', Zaxis'];
    loc2glob = [RotMat, Origin';
                0 0 0 1]; 
    % These tranformation matrices convert from local to global CS.
    % Invert them to go from global to local.
       glob2loc = [RotMat', -(RotMat')*Origin'; 0 0 0 1];
    R_glob2loc = glob2loc(1:3,1:3);
    T_glob2loc = glob2loc(1:3,4);
    
    % Transforming data to radius CS (to make one large plot)
    Sca2 = (glob2loc * [V_Sca.' ; ones(1,size(V_Sca,1))]).';
    Sca2 = Sca2(:,1:3);
    V_Rad = R_glob2loc*V_Rad.' + repmat(T_glob2loc,1,size(V_Rad,1)); V_Rad = V_Rad.';
    Trap2 = (glob2loc * [V_Trap.' ; ones(1,size(V_Trap,1))]).';
    Trap2 = Trap2(:,1:3);
    MC2 = (glob2loc * [V_MC.' ; ones(1,size(V_MC,1))]).';
    MC2 = MC2(:,1:3);
    
    % Plot stl's and helical axes
    h8 = figure;
    [obj, li, ax] = GUI_PlotShells(h8, {F_Rad;F_Trap;F_MC;F_Sca}, {V_Rad;Trap2;MC2;Sca2},...
            {ones(size(V_Rad,1),1),ones(size(Trap2,1),1),ones(size(MC2,1),1),ones(size(Sca2,1),1)});
    hold on
    arrow([0;0;0],[10;0;0],5,70,30);
    arrow([0;0;0],[0;10;0],5,70,30);
    arrow([0;0;0],[0;0;10],5,70,30);
    
    for nr = 1:length(available)-1
    arrow(point_Sca(:,nr)-200*n_Sca(:,nr),point_Sca(:,nr)+200*n_Sca(:,nr),5,70,30,'EdgeColor','r','FaceColor','r');
    arrow(point_Trap(:,nr)-200*n_Trap(:,nr),point_Trap(:,nr)+200*n_Trap(:,nr),5,70,30,'EdgeColor','g','FaceColor','g');
    arrow(point_MC(:,nr)-200*n_MC(:,nr),point_MC(:,nr)+200*n_MC(:,nr),5,70,30,'EdgeColor','b','FaceColor','b');
    end
    line(average(1:2,1),average(1:2,2),average(1:2,3),'Color','r','LineWidth',4)
    line(average(3:4,1),average(3:4,2),average(3:4,3),'Color','g','LineWidth',4)
    line(average(5:6,1),average(5:6,2),average(5:6,3),'Color','b','LineWidth',4)
    scatter3(PivotPoints(:,1),PivotPoints(:,2),PivotPoints(:,3),50,'black','filled');
    hold off;
end


