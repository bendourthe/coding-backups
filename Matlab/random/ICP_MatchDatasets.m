function varargout = ICP_MatchDatasets(varargin)
%ICP_MatchDatasets  Find pairs of closest points between two datasets.
%
%   Syntax:
%    conn = ICP_MatchDatasets(Vmod)
%    [points_mod, err] = ICP_MatchDatasets(Vdat, Vmod, conn, init)
%
%   Input:
%    Vdat: N-by-3 array containing vertex coordinates. Each row represents
%          a vertex in the data set; the first, second and third columns
%          represent X-, Y- and Z-coordinates respectively.
%    Vmod: N-by-3 array containing vertex coordinates. Each row represents
%          a vertex in the model set; the first, second and third columns
%          represent X-, Y- and Z-coordinates respectively.
%    conn: N-by-1 cell array containing column vectors of row indices into
%          Vmod. Each column vector corresponds with a vertex in Vmod and
%          indicates which other vertices in Vmod are connected to it. This
%          cell array containing connectivity information for the model set
%          may be generated by using the first syntax. Optional; if
%          omitted, connectivity information will not be used.
%    init: Column vector containing row indices into Vmod. Each element
%          corresponds to a point in Vdat and indicates to which model
%          point in Vmod that data point is paired. This variable serves as
%          an initialisation for points_mod. Optional, defaults to
%          ones(size(Vdat, 1), 1).
%
%   Output:
%    conn:       N-by-1 cell array containing column vectors of row indices
%                into Vmod. Each column vector corresponds with a vertex in
%                Vmod and indicates which other vertices in Vmod are
%                connected to it, based on a 3D Delaunay tessellation.
%    points_mod: Column vector containing row indices into Vmod. Each
%                element corresponds to a point in Vdat and indicates to
%                which model point in Vmod that data point is paired.
%    err:        Column vector containing squared distances. Each element
%                corresponds to a point in Vdat and indicates the squared
%                distance from that point to the model point in Vmod to
%                which it is paired.
%
%   Effect: For each point in the data set, this function will find the
%   nearest point in the model set. The first syntax may be used to
%   generate connectivity information based on a 3D Delaunay tessellation.
%   This information can be used to speed up the search process in the
%   second syntax. This is done by initialising points_mod to a certain set
%   of points (e.g. the result from a previous iteration) and "walking"
%   along the edges of the tessellation, choosing points that are as close
%   as possible to the considered data point, until no more closer points
%   can be found.
%
%   Dependencies: Graph_Simplices2Edges.m
%                 Graph_Edges2Connectivity.m
%                 SquaredDistanceFromVertexToVertex.m
%
%   Known parents: ICP_RegisterDatasets.m
%                  Muscle_CutByRegionBorder.m
%                  Muscle_AlignRegion.m
%                  Muscle_SelectDatabaseBone.m

%Created on 29/11/2006 by Ward Bartels.
%WB, 01/12/2006: Inlined SquaredDistanceFromVertexToVertex.m.
%WB, 22/12/2006: Graph functions now used for determining connectivity;
%                added output of err.
%Stabile, fully functional.


%Check if connectivity array is requested
if nargin==1
    
    % %Extract model set from input
    % Vmod = varargin{1};
    % 
    % %Tessellate
    % T = delaunayn(Vmod);
    % 
    % %Get all edges in the tessellation <<Graph_Simplices2Edges.m>>
    % edges = Graph_Simplices2Edges(T);
    % 
    % %Assemble connection array <<Graph_Edges2Connectivity.m>>
    % varargout{1} = Graph_Edges2Connectivity(edges, 'cell');
    
    %Tessellate
    varargout{1} = delaunayn(varargin{1});
    
    
else
    
    %Extract data and model set from input
    [Vdat, Vmod] = varargin{[1 2]};
    
    %Preallocate output arguments
    points_mod = zeros(size(Vdat, 1), 1);
    err = points_mod;
    
    %Check if connectivity array was provided
    if nargin>=3
        
        % %Handle additional input
        % conn = varargin{3};
        % if nargin>=4
        %     init = varargin{4};
        % else
        %     init = ones(size(Vdat, 1), 1);
        % end
        % 
        % %Loop over all data points
        % for ind = 1:size(Vdat, 1)
        % 
        %     %Store data point
        %     pdat = Vdat(ind,:);
        % 
        %     %Initialise model point ref and squared distance to data point
        %     point = init(ind);
        %     dist = sum(realpow(Vmod(point,:)-pdat, 2), 2);
        %     dist_old = Inf;
        % 
        %     %Loop until no model point closer to the data point is found
        %     while dist<dist_old
        % 
        %         %Store previous point and dist
        %         point_old = point;
        %         dist_old = dist;
        % 
        %         %Get list of potential new model points
        %         point = conn{point_old};
        % 
        %         %Calculate distances from new model points to data point
        %         pmod = Vmod(point,:);
        %         dist = sum(realpow(pmod, 2), 2)+pdat*pdat.'-2*(pmod*pdat.');
        % 
        %         %Keep only point with minimum distance
        %         [dist, jnd] = min(dist);
        %         point = point(jnd);
        %     end
        % 
        %     %Store model point and error distance
        %     points_mod(ind,1) = point_old;
        %     err(ind,1) = dist_old;
        % end
        
        %Go to private directory of dsearchn
        dir_orig = cd;
        cd(fullfile(fileparts(which('dsearchn')), 'private', ''));
        
        %Look for closest points across tessellation
        [points_mod, err] = tsrchnmx(Vmod.', varargin{3}, Vdat.', 1); %Inlined dsearchn.m
        
        %Return to original directory
        cd(dir_orig);
        
    else
        
        %Loop over all data points
        for ind = 1:size(Vdat, 1)
            
            %Calculate distances from all model points to data point
            %<<SquaredDistanceFromVertexToVertex.m>>
            dist = SquaredDistanceFromVertexToVertex(Vdat(ind,:), Vmod);
            
            %Store model point with minimum distance, and error distance
            [err(ind,1), points_mod(ind,1)] = min(dist);
        end
    end
    
    %Store output
    varargout = {points_mod err};
end